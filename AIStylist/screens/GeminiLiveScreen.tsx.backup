/**
 * Gemini Live Mode Screen
 * Real-time outfit scoring and styling conversation with Gemini 2.5 Flash
 * Features:
 * - Live video streaming to AI
 * - Real-time audio conversation
 * - Instant outfit feedback
 * - Natural, buddy-like interaction
 */

import React, { useState, useRef, useCallback, useEffect } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
  ActivityIndicator,
  Platform,
  Alert,
} from 'react-native';
import { CameraView, CameraType, useCameraPermissions } from 'expo-camera';
import { Mic, MicOff, X, PhoneOff, RotateCw } from 'lucide-react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { router } from 'expo-router';
import { WebView } from 'react-native-webview';
import Constants from 'expo-constants';

import Colors from '@/constants/colors';

import { getGeminiLiveHTML } from '@/AIStylist/utils/geminiLiveHTML';
import { videoStreamService } from '@/AIStylist/services/VideoStreamService';

export default function GeminiLiveScreen() {
  const insets = useSafeAreaInsets();

  console.log('üé® GeminiLiveScreen rendered');
  console.log('üì± Platform:', Platform.OS);

  // Use WebView for ALL platforms - it mimics a real browser
  // This way the @google/genai SDK works properly
  return <GeminiLiveWebViewScreen />;
}

/**
 * Native Gemini Live Screen for iOS/Android
 * Direct WebSocket connection - no WebView needed!
 */
function GeminiLiveNativeScreen() {
  const insets = useSafeAreaInsets();
  const [facing, setFacing] = useState<CameraType>('front');
  const [permission, requestPermission] = useCameraPermissions();
  const [session, setSession] = useState<GeminiLiveNativeSession>({
    isActive: false,
    isConnecting: false,
    isMuted: false,
    videoEnabled: true,
    userTranscription: '',
    modelTranscription: '',
    error: null,
  });

  const cameraRef = useRef<CameraView>(null);
  const nativeManagerRef = useRef<GeminiLiveNativeFixed | null>(null);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      handleStopCall();
    };
  }, []);

  const startWithWebSocket = useCallback(async (apiKey: string) => {
    try {
      console.log('üîå Starting WebSocket implementation with real-time audio...');
      
      // Initialize Native Gemini Live Manager with expo-audio-stream
      const manager = new GeminiLiveNativeFixed(apiKey);
      nativeManagerRef.current = manager;

      if (!cameraRef.current) {
        throw new Error('Camera not ready');
      }

      // Start session with callbacks
      await manager.startSession(
        cameraRef.current,
        {
          onSessionUpdate: (update) => {
            setSession(prev => ({ ...prev, ...update }));
          },
          onError: (error) => {
            console.error('‚ùå Session error:', error);
            setSession(prev => ({ ...prev, error, isActive: false, isConnecting: false }));
            // Only show alert for critical errors, not SDK fallback messages
            if (!error.includes('SDK') && !error.includes('@google/genai')) {
              Alert.alert('Error', error);
            }
          },
          onTranscription: (type, text) => {
            if (type === 'user') {
              setSession(prev => ({ ...prev, userTranscription: text }));
            } else {
              setSession(prev => ({ ...prev, modelTranscription: text }));
            }
          },
          onAudioResponse: (audioData) => {
            console.log('üîä Playing AI response');
          },
        },
        { videoEnabled: session.videoEnabled }
      );

      console.log('‚úÖ Native session started successfully!');
    } catch (error) {
      console.error('‚ùå Failed to start session:', error);
      const message = error instanceof Error ? error.message : 'Failed to start session';
      setSession(prev => ({ ...prev, error: message, isConnecting: false }));
      Alert.alert('Connection Error', message);
    }
  }, [session.videoEnabled]);

  const handleStartCall = useCallback(async () => {
    try {
      if (!permission?.granted) {
        console.log('üì∏ Requesting camera permission...');
        const result = await requestPermission();
        if (!result.granted) {
          Alert.alert('Permission Required', 'Camera and microphone access is needed for live mode.');
          return;
        }
        console.log('‚úÖ Camera permission granted');
      }

      if (!cameraRef.current) {
        Alert.alert('Error', 'Camera not ready. Please try again.');
        return;
      }

      // Get API key
      const apiKey = Constants.expoConfig?.extra?.geminiApiKey || process.env.EXPO_PUBLIC_GEMINI_API_KEY;
      if (!apiKey) {
        setSession(prev => ({
          ...prev,
          error: 'API key not configured. Please set EXPO_PUBLIC_GEMINI_API_KEY.',
        }));
        return;
      }

      console.log('üöÄ Starting NATIVE Gemini Live session with WebSocket');

      // Use WebSocket implementation directly (SDK doesn't work on React Native)
      await startWithWebSocket(apiKey);
    } catch (error) {
      console.error('‚ùå Failed to start native session:', error);
      const message = error instanceof Error ? error.message : 'Failed to start session';
      setSession(prev => ({ ...prev, error: message, isConnecting: false }));
      Alert.alert('Error', message);
    }
  }, [permission, requestPermission, session.videoEnabled, startWithWebSocket]);

  const handleStopCall = useCallback(async () => {
    if (nativeManagerRef.current) {
      await nativeManagerRef.current.stopSession();
      nativeManagerRef.current = null;
    }

    setSession({
      isActive: false,
      isConnecting: false,
      isMuted: false,
      videoEnabled: true,
      userTranscription: '',
      modelTranscription: '',
      error: null,
    });
  }, []);

  const handleToggleMute = useCallback(() => {
    if (nativeManagerRef.current) {
      const newMuted = !session.isMuted;
      nativeManagerRef.current.setMuted(newMuted);
    }
  }, [session.isMuted]);

  const toggleCameraFacing = useCallback(() => {
    setFacing(current => (current === 'back' ? 'front' : 'back'));
  }, []);

  const toggleVideo = useCallback(() => {
    if (session.isActive) {
      // Can toggle during session
      if (nativeManagerRef.current) {
        const newVideoEnabled = !session.videoEnabled;
        nativeManagerRef.current.setVideoEnabled(newVideoEnabled);
      }
    } else {
      // Toggle before session
      setSession(prev => ({ ...prev, videoEnabled: !prev.videoEnabled }));
    }
  }, [session.isActive, session.videoEnabled]);

  const handleClose = useCallback(() => {
    handleStopCall();
    router.back();
  }, [handleStopCall]);

  if (!permission) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color={Colors.primary} />
      </View>
    );
  }

  if (!permission.granted) {
    return (
      <View style={styles.container}>
        <Text style={styles.permissionText}>Camera and microphone access is required</Text>
        <TouchableOpacity style={styles.permissionButton} onPress={requestPermission}>
          <Text style={styles.permissionButtonText}>Grant Permission</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      {/* Camera View */}
      <View style={styles.cameraContainer}>
        <CameraView
          ref={cameraRef}
          style={styles.camera}
          facing={facing}
        />

        {/* Close Button */}
        <TouchableOpacity
          style={[styles.closeButton, { top: insets.top + 10 }]}
          onPress={handleClose}
        >
          <X size={24} color="#fff" />
        </TouchableOpacity>

        {/* Flip Camera Button */}
        {!session.isActive && (
          <TouchableOpacity
            style={[styles.flipButton, { top: insets.top + 10 }]}
            onPress={toggleCameraFacing}
          >
            <RotateCw size={24} color="#fff" />
          </TouchableOpacity>
        )}

        {/* Video Toggle Button */}
        <TouchableOpacity
          style={[styles.videoIndicator, { top: insets.top + 60 }]}
          onPress={toggleVideo}
        >
          <Text style={styles.videoIndicatorText}>
            {session.videoEnabled ? 'üìπ Video On' : 'üé§ Audio Only'}
          </Text>
        </TouchableOpacity>

        {/* Native Badge */}
        <View style={[styles.nativeBadge, { top: insets.top + 100 }]}>
          <Text style={styles.nativeBadgeText}>‚ö° Real-Time Audio</Text>
        </View>

        {/* Overlay for non-active states */}
        {!session.isActive && !session.isConnecting && (
          <View style={styles.overlay}>
            <Text style={styles.title}>Gemini Live Stylist</Text>
            <Text style={styles.subtitle}>Real-time outfit scoring & styling advice</Text>
            <Text style={styles.nativeLabel}>‚ö° Native with Real-Time Audio Streaming</Text>
            
            <TouchableOpacity
              style={[styles.videoToggleButton, session.videoEnabled && styles.videoToggleButtonActive]}
              onPress={toggleVideo}
            >
              <Text style={styles.videoToggleButtonText}>
                {session.videoEnabled ? 'üìπ Video Mode' : 'üé§ Audio Only'}
              </Text>
            </TouchableOpacity>

            <TouchableOpacity style={styles.startButton} onPress={handleStartCall}>
              <Mic size={24} color="#fff" />
              <Text style={styles.startButtonText}>Start Live Session</Text>
            </TouchableOpacity>
          </View>
        )}

        {session.isConnecting && (
          <View style={styles.overlay}>
            <ActivityIndicator size="large" color="#fff" />
            <Text style={styles.connectingText}>Connecting to Gemini...</Text>
          </View>
        )}

        {/* Transcription Display */}
        {session.isActive && (
          <View style={styles.transcriptionContainer}>
            {session.userTranscription && (
              <View style={styles.transcriptionBox}>
                <Text style={styles.transcriptionLabel}>You:</Text>
                <Text style={styles.transcriptionText}>{session.userTranscription}</Text>
              </View>
            )}
            {session.modelTranscription && (
              <View style={[styles.transcriptionBox, styles.modelTranscriptionBox]}>
                <Text style={[styles.transcriptionLabel, styles.modelLabel]}>Gemini:</Text>
                <Text style={styles.transcriptionText}>{session.modelTranscription}</Text>
              </View>
            )}
          </View>
        )}
      </View>

      {/* Controls */}
      {session.isActive && (
        <View style={[styles.controls, { paddingBottom: insets.bottom + 20 }]}>
          <TouchableOpacity
            style={[styles.controlButton, !session.videoEnabled && styles.mutedButton]}
            onPress={toggleVideo}
          >
            <Text style={styles.controlButtonText}>
              {session.videoEnabled ? 'üìπ' : 'üì∑'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.endCallButton} onPress={handleStopCall}>
            <PhoneOff size={32} color="#fff" />
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.controlButton, session.isMuted && styles.mutedButton]}
            onPress={handleToggleMute}
          >
            {session.isMuted ? <MicOff size={28} color="#fff" /> : <Mic size={28} color="#fff" />}
          </TouchableOpacity>
        </View>
      )}

      {/* Error Display */}
      {session.error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{session.error}</Text>
        </View>
      )}
    </View>
  );
}

/**
 * WebView Gemini Live Screen - Works on ALL platforms
 * Uses full browser environment to run @google/genai SDK
 */
function GeminiLiveWebViewScreen() {
  const insets = useSafeAreaInsets();
  const apiKey = Constants.expoConfig?.extra?.geminiApiKey || process.env.EXPO_PUBLIC_GEMINI_API_KEY;
  console.log('üîë API Key present:', !!apiKey);
  
  if (!apiKey) {
    return (
      <View style={[styles.container, { paddingTop: insets.top }]}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorTitle}>‚ö†Ô∏è Configuration Required</Text>
          <Text style={styles.errorMessage}>
            Gemini API key not found. Please set EXPO_PUBLIC_GEMINI_API_KEY in your .env file.
          </Text>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <Text style={styles.backButtonText}>Go Back</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  const html = getGeminiLiveHTML(apiKey);
  console.log('üìÑ Full HTML with embedded SDK loaded');
  console.log('ÔøΩ P latform:', Platform.OS);

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.webViewHeader}>
        <TouchableOpacity
          style={styles.closeButtonMobile}
          onPress={() => {
            console.log('‚ùå Close button pressed');
            router.back();
          }}
        >
          <X size={24} color="#fff" />
        </TouchableOpacity>
        <Text style={styles.webViewTitle}>üé® AI Stylist Live</Text>
        <View style={{ width: 44 }} />
      </View>
      <WebView
        source={{ html, baseUrl: 'https://localhost/' }}
        style={styles.webView}
        originWhitelist={['*']}
        mediaPlaybackRequiresUserAction={false}
        allowsInlineMediaPlayback={true}
        mediaCapturePermissionGrantType="grant"
        javaScriptEnabled={true}
        domStorageEnabled={true}
        startInLoadingState={true}
        mixedContentMode="always"
        allowsProtectedMedia={true}
        renderLoading={() => (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={Colors.primary} />
            <Text style={styles.loadingText}>Loading Gemini Live...</Text>
          </View>
        )}
        onLoadStart={() => console.log('üîÑ WebView load started')}
        onLoadEnd={() => console.log('‚úÖ WebView load ended')}
        onLoad={() => console.log('üì± WebView loaded successfully')}
        onMessage={(event) => {
          try {
            const data = JSON.parse(event.nativeEvent.data);
            console.log('üì® WebView message:', data.type);
            if (data.type === 'close') {
              router.back();
            } else if (data.type === 'error') {
              console.error('‚ö†Ô∏è WebView error:', data.message);
            }
          } catch (e) {
            console.log('üìÑ Raw message:', event.nativeEvent.data);
          }
        }}
        onError={(syntheticEvent) => {
          const { nativeEvent } = syntheticEvent;
          console.error('‚ùå WebView error:', nativeEvent);
          Alert.alert('Error', 'Failed to load. Please check your internet connection.');
        }}
        onHttpError={(syntheticEvent) => {
          console.warn('‚ö†Ô∏è HTTP error:', syntheticEvent.nativeEvent);
        }}
      />
    </View>
  );
}

  const [facing, setFacing] = useState<CameraType>('front');
  const [permission, requestPermission] = useCameraPermissions();
  const [session, setSession] = useState<GeminiLiveSession>({
    isActive: false,
    isConnecting: false,
    isMuted: false,
    userTranscription: '',
    modelTranscription: '',
    error: null,
  });
  const [videoEnabled, setVideoEnabled] = useState<boolean>(true);

  const cameraRef = useRef<CameraView>(null);
  const liveManagerRef = useRef<GeminiLiveManager | null>(null);
  const mediaStreamRef = useRef<MediaStream | null>(null);

  // Setup camera reference for video streaming
  useEffect(() => {
    if (cameraRef.current) {
      videoStreamService.setupCamera(cameraRef.current);
    }
  }, [cameraRef.current]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      handleStopCall();
      videoStreamService.cleanup();
    };
  }, []);

  const handleStartCall = useCallback(async () => {
    if (Platform.OS !== 'web') {
      Alert.alert(
        'Web Only Feature',
        'Gemini Live mode is currently only available on web. Please use the standard AI Stylist mode on mobile.',
        [{ text: 'OK' }]
      );
      return;
    }

    if (!permission?.granted) {
      const result = await requestPermission();
      if (!result.granted) {
        Alert.alert('Permission Required', 'Camera and microphone access is needed for live mode.');
        return;
      }
    }

    try {
      // Get API key from environment
      const apiKey = process.env.EXPO_PUBLIC_GEMINI_API_KEY;
      if (!apiKey) {
        setSession(prev => ({
          ...prev,
          error: 'API key not configured. Please set EXPO_PUBLIC_GEMINI_API_KEY.',
        }));
        return;
      }

      // Request camera and microphone access
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { facingMode: facing === 'front' ? 'user' : 'environment' },
      });

      mediaStreamRef.current = stream;

      // Initialize Gemini Live Manager
      const manager = new GeminiLiveManager(apiKey);
      liveManagerRef.current = manager;

      // Start session with callbacks
      await manager.startSession(
        stream,
        {
          onSessionUpdate: (update) => {
            setSession(prev => ({ ...prev, ...update }));
          },
          onError: (error) => {
            setSession(prev => ({ ...prev, error, isActive: false, isConnecting: false }));
            Alert.alert('Error', error);
          },
          onAudioData: (audioData) => {
            // Audio data is handled internally by the manager
          },
          onTranscription: (type, text) => {
            if (type === 'user') {
              setSession(prev => ({ ...prev, userTranscription: text }));
            } else {
              setSession(prev => ({ ...prev, modelTranscription: text }));
            }
          },
        },
        { videoEnabled } // Pass video enabled option
      );
    } catch (error) {
      console.error('Failed to start Gemini Live session:', error);
      const message = error instanceof Error ? error.message : 'Failed to start session';
      setSession(prev => ({ ...prev, error: message, isConnecting: false }));
      Alert.alert('Error', message);
    }
  }, [permission, requestPermission, facing]);

  const handleStopCall = useCallback(async () => {
    // Stop video streaming
    videoStreamService.stopStreaming();

    if (liveManagerRef.current) {
      await liveManagerRef.current.stopSession();
      liveManagerRef.current = null;
    }

    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach(track => track.stop());
      mediaStreamRef.current = null;
    }

    setSession({
      isActive: false,
      isConnecting: false,
      isMuted: false,
      userTranscription: '',
      modelTranscription: '',
      error: null,
    });
  }, []);

  const handleToggleMute = useCallback(() => {
    if (liveManagerRef.current) {
      const newMuted = !session.isMuted;
      liveManagerRef.current.setMuted(newMuted);
    }
  }, [session.isMuted]);

  const toggleCameraFacing = useCallback(() => {
    setFacing(current => (current === 'back' ? 'front' : 'back'));
  }, []);

  const toggleVideo = useCallback(() => {
    if (session.isActive) {
      Alert.alert(
        'Video Toggle',
        'Stop the call before changing video settings',
        [{ text: 'OK' }]
      );
      return;
    }
    setVideoEnabled(!videoEnabled);
  }, [session.isActive, videoEnabled]);

  const handleClose = useCallback(() => {
    handleStopCall();
    router.back();
  }, [handleStopCall]);

  if (!permission) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color={Colors.primary} />
      </View>
    );
  }

  if (!permission?.granted) {
    return (
      <View style={styles.container}>
        <Text style={styles.permissionText}>Camera and microphone access is required</Text>
        <TouchableOpacity style={styles.permissionButton} onPress={requestPermission}>
          <Text style={styles.permissionButtonText}>Grant Permission</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      {/* Camera View */}
      <View style={styles.cameraContainer}>
        <CameraView
          ref={cameraRef}
          style={styles.camera}
          facing={facing}
        />

        {/* Close Button */}
        <TouchableOpacity
          style={[styles.closeButton, { top: insets.top + 10 }]}
          onPress={handleClose}
        >
          <X size={24} color="#fff" />
        </TouchableOpacity>

        {/* Flip Camera Button */}
        {!session.isActive && (
          <TouchableOpacity
            style={[styles.flipButton, { top: insets.top + 10 }]}
            onPress={toggleCameraFacing}
          >
            <RotateCw size={24} color="#fff" />
          </TouchableOpacity>
        )}

        {/* Video Toggle Indicator */}
        <View style={[styles.videoIndicator, { top: insets.top + 60 }]}>
          <Text style={styles.videoIndicatorText}>
            {videoEnabled ? 'üìπ Video On' : 'üé§ Audio Only'}
          </Text>
        </View>

        {/* Overlay for non-active states */}
        {!session.isActive && !session.isConnecting && (
          <View style={styles.overlay}>
            <Text style={styles.title}>Gemini Live Stylist</Text>
            <Text style={styles.subtitle}>Real-time outfit scoring & styling advice</Text>
            
            <TouchableOpacity
              style={[styles.videoToggleButton, videoEnabled && styles.videoToggleButtonActive]}
              onPress={toggleVideo}
            >
              <Text style={styles.videoToggleButtonText}>
                {videoEnabled ? 'üìπ Video Mode' : 'üé§ Audio Only'}
              </Text>
            </TouchableOpacity>

            <TouchableOpacity style={styles.startButton} onPress={handleStartCall}>
              <Mic size={24} color="#fff" />
              <Text style={styles.startButtonText}>Start Live Session</Text>
            </TouchableOpacity>
            {Platform.OS !== 'web' && (
              <Text style={styles.webOnlyText}>‚ö†Ô∏è Web only feature</Text>
            )}
          </View>
        )}

        {session.isConnecting && (
          <View style={styles.overlay}>
            <ActivityIndicator size="large" color="#fff" />
            <Text style={styles.connectingText}>Connecting to Gemini...</Text>
          </View>
        )}

        {/* Transcription Display */}
        {session.isActive && (
          <View style={styles.transcriptionContainer}>
            {session.userTranscription && (
              <View style={styles.transcriptionBox}>
                <Text style={styles.transcriptionLabel}>You:</Text>
                <Text style={styles.transcriptionText}>{session.userTranscription}</Text>
              </View>
            )}
            {session.modelTranscription && (
              <View style={[styles.transcriptionBox, styles.modelTranscriptionBox]}>
                <Text style={[styles.transcriptionLabel, styles.modelLabel]}>Gemini:</Text>
                <Text style={styles.transcriptionText}>{session.modelTranscription}</Text>
              </View>
            )}
          </View>
        )}
      </View>

      {/* Controls */}
      {session.isActive && (
        <View style={[styles.controls, { paddingBottom: insets.bottom + 20 }]}>
          <TouchableOpacity
            style={[styles.controlButton, session.isMuted && styles.mutedButton]}
            onPress={handleToggleMute}
          >
            {session.isMuted ? <MicOff size={28} color="#fff" /> : <Mic size={28} color="#fff" />}
          </TouchableOpacity>

          <TouchableOpacity style={styles.endCallButton} onPress={handleStopCall}>
            <PhoneOff size={32} color="#fff" />
          </TouchableOpacity>
        </View>
      )}

      {/* Error Display */}
      {session.error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{session.error}</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  webView: {
    flex: 1,
    backgroundColor: '#000',
  },
  webViewHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  webViewTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  closeButtonMobile: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#000',
  },
  loadingText: {
    marginTop: 16,
    color: '#fff',
    fontSize: 16,
  },
  cameraContainer: {
    flex: 1,
    position: 'relative',
  },
  camera: {
    flex: 1,
  },
  closeButton: {
    position: 'absolute',
    left: 20,
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  flipButton: {
    position: 'absolute',
    right: 20,
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  videoIndicator: {
    position: 'absolute',
    left: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  videoIndicatorText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  videoToggleButton: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 25,
    backgroundColor: 'rgba(107, 114, 128, 0.8)',
    marginBottom: 16,
  },
  videoToggleButtonActive: {
    backgroundColor: 'rgba(99, 102, 241, 0.8)',
  },
  videoToggleButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    color: '#ccc',
    marginBottom: 32,
    textAlign: 'center',
  },
  startButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    backgroundColor: Colors.primary,
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 30,
  },
  startButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  webOnlyText: {
    marginTop: 16,
    color: '#fbbf24',
    fontSize: 14,
  },
  connectingText: {
    marginTop: 16,
    color: '#fff',
    fontSize: 18,
  },
  transcriptionContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 16,
    backgroundColor: 'linear-gradient(to top, rgba(0,0,0,0.8), transparent)',
  },
  transcriptionBox: {
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    padding: 12,
    borderRadius: 12,
    marginBottom: 8,
  },
  modelTranscriptionBox: {
    backgroundColor: 'rgba(99, 102, 241, 0.3)',
  },
  transcriptionLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#60a5fa',
    marginBottom: 4,
  },
  modelLabel: {
    color: '#a78bfa',
  },
  transcriptionText: {
    fontSize: 16,
    color: '#fff',
    lineHeight: 22,
  },
  controls: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 24,
    paddingTop: 20,
  },
  controlButton: {
    width: 64,
    height: 64,
    borderRadius: 32,
    backgroundColor: 'rgba(107, 114, 128, 0.8)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  mutedButton: {
    backgroundColor: 'rgba(251, 191, 36, 0.8)',
  },
  endCallButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#ef4444',
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
    backgroundColor: '#000',
  },
  errorTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#fbbf24',
    marginBottom: 16,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    color: '#ccc',
    marginBottom: 12,
    textAlign: 'center',
    lineHeight: 24,
  },
  errorText: {
    color: '#fff',
    fontSize: 14,
    textAlign: 'center',
  },
  backButton: {
    marginTop: 24,
    backgroundColor: Colors.primary,
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 12,
  },
  backButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  permissionText: {
    fontSize: 18,
    color: '#fff',
    textAlign: 'center',
    marginBottom: 20,
  },
  permissionButton: {
    backgroundColor: Colors.primary,
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 12,
  },
  permissionButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  nativeBadge: {
    position: 'absolute',
    left: 20,
    backgroundColor: 'rgba(16, 185, 129, 0.9)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: 'rgba(52, 211, 153, 0.5)',
  },
  nativeBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  nativeLabel: {
    color: '#10b981',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 16,
    textAlign: 'center',
  },
  controlButtonText: {
    fontSize: 24,
  },
});
